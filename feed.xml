<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://www.yoonholee.com/feed.xml" rel="self" type="application/atom+xml"/><link href="https://www.yoonholee.com/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-01-26T19:48:59+00:00</updated><id>https://www.yoonholee.com/feed.xml</id><title type="html">Yoonho Lee</title><subtitle>Personal website of Yoonho Lee, Ph.D. candidate at Stanford CS.</subtitle><entry><title type="html">Following the Text Gradient at Scale</title><link href="https://www.yoonholee.com/blog/2025/feedback-descent/" rel="alternate" type="text/html" title="Following the Text Gradient at Scale"/><published>2025-12-01T00:00:00+00:00</published><updated>2025-12-01T00:00:00+00:00</updated><id>https://www.yoonholee.com/blog/2025/feedback-descent</id><content type="html" xml:base="https://www.yoonholee.com/blog/2025/feedback-descent/"><![CDATA[<h2 id="rl-throws-away-almost-everything-evaluators-have-to-say">RL Throws Away Almost Everything Evaluators Have to Say</h2> <p>When you get feedback on your work, it usually tells you <em>what</em> went wrong and <em>how</em> to fix it. But existing reinforcement learning (RL) algorithms throw most of that information away; it compresses potentially rich feedback into a single number, a reward<sup id="fnref:dense"><a href="#fn:dense" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>, then tries to learn by correlating rewards with actions across hundreds or thousands of attempts. We do this because our algorithms were designed for scalar supervision, not because of a fundamental constraint in learning from experience<sup id="fnref:rl-gap"><a href="#fn:rl-gap" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p> <p>To illustrate this, let‚Äôs consider a simple example. Suppose you‚Äôre judging cakes. You take a bite, you like the shavings on top, the ganache is perfectly tempered, but you want way more cherries throughout. Yet you only record: ‚Äú4/5.‚Äù The baker learns nothing about the cherry distribution or what else worked well, only that this cake scored higher than a 3. If this is the only information you provide, the baker will likely have to do <strong>a lot</strong> more baking to figure out what you actually want. <sup id="fnref:cake-reference"><a href="#fn:cake-reference" class="footnote" rel="footnote" role="doc-noteref">3</a></sup></p> <p><img src="/assets/img/feedback-descent/cake.png" alt="Cake example"/></p> <p>More generally, an expert given a candidate solution can articulate specific failure modes, causal mechanisms, and concrete fixes. Full verbal feedback for the cake above would contain far more actionable information than the numerical score ‚Äú4/5‚Äù. The baker can confidently keep the parts of the cake that worked well, rather than blindly exploring recipe variations. This is the core insight: rich feedback enables targeted improvements rather than random exploration, resulting in fewer trials to achieve a better outcome.</p> <p>This striking mismatch between the information available and the information used by RL has been aptly described as <a href="https://youtu.be/lXUZvyajciY?si=fez_SbjEhp2y3FZF&amp;t=2597">sucking supervision through a straw</a>: you run minutes of rollout and compress it all into a final reward signal broadcast across the entire trajectory. This scalar bottleneck is becoming increasingly costly in the tasks we‚Äôre deploying LLMs on: for example, <a href="https://blog.google/products/search/deep-search-business-calling-google-search/">research</a> <a href="https://openai.com/index/introducing-deep-research/">agents</a> run 5-30 minutes per task. Each run produces rich diagnostic logs‚Äîtool calls, intermediate reasoning, error traces‚Äîall of which are collapsed into a single scalar that discards the causal signal of where and why things failed. While rich feedback requires a bit more work from the evaluator, they‚Äôve already done the reasoning; we‚Äôre just asking them to write it down. When rollouts themselves are expensive, the marginal annotation cost is small relative to the sample-efficiency gains we can achieve with richer feedback.</p> <p>In this post, we survey an emerging learning paradigm that fully embraces all the feedback an environment has to offer‚Äîavoiding the scalar bottleneck of RL‚Äîand discuss our recent work called <strong>Feedback Descent</strong> (check out the paper <a href="https://arxiv.org/abs/2511.07919">here</a>), which outperforms specialized RL methods in challenging optimization domains such as molecular design and prompt optimization.</p> <h2 id="from-scalar-rewards-to-text-based-optimization">From Scalar Rewards to Text-Based Optimization</h2> <p>A growing body of work hints at an alternative to reward-based learning: directly using rich feedback to guide model improvement. Given a textual artifact (e.g., a prompt, source code, molecule specs), we can often provide natural-language explanations of how to improve it. That explanation is already a form of supervision. Rather than compressing it into a single number, we can feed it back into the system during the update.</p> <p>In recent work, two broad patterns have emerged around this principle:</p> <ul> <li><strong>Critique-based or ‚Äútext gradient‚Äù methods.</strong> The model proposes an artifact and receives a natural-language critique of its errors or omissions. The critique explicitly suggests a direction of improvement: adjust the retrieval query, remove this redundancy, change the control flow, etc. A revised artifact is then produced by editing the original in line with the critique. This pattern appears in systems such as <a href="https://arxiv.org/abs/2303.17651">Self-Refine</a>, <a href="https://arxiv.org/abs/2305.03495">APO</a>, <a href="https://arxiv.org/abs/2406.16218">Trace</a>, and <a href="https://arxiv.org/abs/2406.07496">TextGrad</a>.</li> <li><strong>Evolutionary methods.</strong> Instead of iteratively editing a single artifact, these methods maintain a population of artifacts. Language models generate mutations and recombinations conditioned on the current population, and evaluators select the better ones. Iterating this variation-selection loop gradually shifts the population toward higher-performing algorithms or designs, as in <a href="https://arxiv.org/abs/2309.08532">EvoPrompt</a>, <a href="https://arxiv.org/abs/2507.19457">GEPA</a>, and <a href="https://arxiv.org/abs/2506.13131">AlphaEvolve</a>/<a href="https://github.com/algorithmicsuperintelligence/openevolve">OpenEvolve</a>, and has driven novel <a href="https://www.nature.com/articles/s41586-023-06924-6">mathematical discoveries</a>.</li> </ul> <p>Both lines demonstrate the same underlying principle: textual feedback can serve as structured supervision, often far more informative than scalar rewards. In the remainder of this post, we build a single, domain-agnostic loop around the two primitives these approaches rely on: an evaluator that produces structured feedback, and an editor that turns <em>accumulated</em> feedback on the current best candidates into concrete revisions. We will demonstrate how this loop can sustain meaningful improvement for up to 1000 iterations, far beyond the stability range of standard self-refinement methods.</p> <h2 id="example-domain-drug-discovery">Example Domain: Drug Discovery</h2> <p>Let‚Äôs make this concrete with a problem where the stakes are high and real-world evaluation is expensive: computational drug discovery. The goal is to find small molecules that bind strongly to a target protein, a critical first step in developing new therapeutics. We can navigate the (huge) space of possible molecules using a standard text representation called SMILES: for example, <code class="language-plaintext highlighter-rouge">COCCc1ccc(OCC(O)CNC(C)C)cc1</code> is metoprolol, one of the most prescribed blockers of ADRB1 (one of our target proteins). Given a target protein, docking simulators can give us a proxy score for binding affinity; if we treat this as a standard RL-style optimization problem, the environment returns only a single scalar reward for each SMILES:</p> <ul> <li>Molecule 1 (<code class="language-plaintext highlighter-rouge">O=C(O)C1=CC=CC=C2C=CCCCCCN1C(=O)c1cccc(c1)C2</code>): Reward = 5.037</li> <li>Molecule 2 (<code class="language-plaintext highlighter-rouge">COCCc1ccc(OCC(O)CNC(C)C)cc1</code>): Reward = 4.236</li> </ul> <p>A scalar reward like this hides almost everything about <em>why</em> one molecule is better than the other. But nothing stops us from designing evaluators that expose a much richer structure. For each candidate, the evaluator can report a detailed breakdown of its molecular properties. Below is a small subset of <a href="https://www.rdkit.org/docs/Cookbook.html">RDKit</a>-computed features for these two molecules<sup id="fnref:molecule-metadata"><a href="#fn:molecule-metadata" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>:</p> <table> <thead> <tr> <th>Property</th> <th>Molecule 1</th> <th>Molecule 2</th> <th>Implication</th> </tr> </thead> <tbody> <tr> <td>Core scaffold</td> <td>macrocycle</td> <td>benzene</td> <td>Rigid fused system vs. flexible benzene</td> </tr> <tr> <td>Docking score</td> <td>‚àí6.8</td> <td>‚àí7.1</td> <td>Molecule 1 binds <em>weaker</em></td> </tr> <tr> <td>Drug-likeness (QED)</td> <td>0.824</td> <td>0.714</td> <td>Molecule 1 is more drug-like</td> </tr> <tr> <td>Basic amines</td> <td>0</td> <td>1</td> <td>No salt bridge with Asp138‚Äîexplains weak binding</td> </tr> <tr> <td>Rotatable bonds</td> <td>1</td> <td>9</td> <td>Rigidity boosts QED but pre-organizes wrong pose</td> </tr> <tr> <td>LogP</td> <td>4.3</td> <td>1.6</td> <td>Too lipophilic, solubility risk</td> </tr> </tbody> </table> <p>A medicinal chemist would be able to look through this table and reason almost immediately:</p> <ul> <li>Molecule 1 has a better overall drug-likeness, but a worse docking score.</li> <li>Molecule 1‚Äôs lack of basic amines explains the weak docking score. Molecule 2 binds better because it forms a salt bridge.</li> <li>A promising candidate would merge the strengths of both: keep the favorable macrocycle scaffold of Molecule 1, but introduce a basic amine.</li> </ul> <p>The scalar reward reveals none of this structure, but the rich feedback exposes a clear path forward. This is precisely the kind of targeted, interpretable guidance that feedback-driven optimization can exploit (and what traditional scalar-based RL discards).</p> <h2 id="the-feedback-descent-algorithm">The Feedback Descent Algorithm</h2> <p>Having seen how rich feedback can reveal an actionable structure beyond what a scalar reward can, we now describe the general framework that turns this idea into a scalable optimization procedure.</p> <p>Feedback Descent is a domain-agnostic loop built from two components:</p> <ol> <li><strong>Evaluators: rich feedback instead of scalars</strong>. An evaluator (an LLM judge, a programmatic tool, or even a human) provides natural-language feedback describing what worked and what didn‚Äôt. For different domains, the feedback may include chemical properties and nearest neighbors in a database (molecules), missing structure or aesthetic flaws (SVG images), or reasoning errors and unmet conditions (prompts). The evaluator exposes <em>why</em> an artifact performs the way it does, rather than just whether it did well or poorly.</li> <li><strong>Editors: revisions guided by accumulated feedback</strong>. The editor is an LLM that takes the top candidates and the evaluator‚Äôs accumulated feedback and outputs a revised version. This is the descent step: the LLM implicitly incorporates the strongest signals from prior feedback into its following proposal.</li> </ol> <p>Feedback Descent alternates these two steps while maintaining a small <em>frontier</em> of top-performing candidates. For each newly proposed candidate, the evaluator provides feedback. We aggregate all prior feedback and pass it to the editor, and the editor proposes a new candidate:</p> <p><img src="/assets/img/feedback-descent/system.png" alt="Feedback Descent framework"/></p> <p>Over many iterations, the candidate population continually improves as useful feedback accumulates and unproductive directions are discarded. Since both evaluation and editing occur entirely through text, the same loop transfers cleanly across domains, with the only domain-specific component being the evaluator that supplies feedback.</p> <h2 id="does-feedback-descent-work">Does Feedback Descent Work?</h2> <p>We applied the same Feedback Descent framework to three fundamentally different domains: molecular design, SVG image optimization, and prompt optimization.</p> <p><strong>Molecular Design.</strong> We compared Feedback Descent with specialized graph-based molecular optimizers that explicitly encode chemical structures, as well as REINVENT, a reinforcement learning method specifically designed for molecular optimization. Feedback Descent, operating purely on text representations (SMILES strings), matched or exceeded these specialized methods. On multiple targets, our text-based approach identified molecules surpassing the 99.9th percentile of DOCKSTRING‚Äôs 260,000-compound database. In several cases, we matched or exceeded the best molecule in the entire database. In this domain, Feedback Descent achieved an average 3.8x reduction in docking calls relative to reinforcement learning (REINVENT).</p> <p><img src="/assets/img/feedback-descent/molecule.png" alt="Molecular design"/></p> <video autoplay="" loop="" muted="" playsinline="" style="width: 100%;"> <source src="/assets/img/feedback-descent/PPARA-compressed.mp4" type="video/mp4"/> </video> <p><strong>SVG Optimization.</strong> Starting from basic SVG drawings, Feedback Descent consistently improved designs through iterative visual critique. After just five iterations, designs reliably outperformed a baseline that conditioned on the judge prompt verbatim, demonstrating a generator-verifier gap where iterative feedback elicits better outputs from the same model.</p> <p><img src="/assets/img/feedback-descent/svg_progression.png" alt="SVG optimization"/> <img src="/assets/img/feedback-descent/svg_grid.png" alt="SVG optimization"/></p> <p><strong>Prompt Optimization.</strong> On four diverse tasks (multi-hop reasoning, instruction following, privacy-aware delegation, and retrieval verification), Feedback Descent achieved competitive performance with GEPA, the state-of-the-art prompt optimization method, while outperforming GRPO, a reinforcement learning baseline.</p> <p><img src="/assets/img/feedback-descent/prompt_optimization.png" alt="Prompt optimization"/></p> <p>Together, these results demonstrate that the same evaluator-editor loop can drive continual improvement in domains that differ in representation, evaluation, and failure modes. The only requirement is that we can obtain and express informative feedback in text; no task-specific optimizers, mutation rules, or architectural changes are needed. The informative signal is carried by the textual feedback itself, and the editor LLM uses this feedback to guide its next revisions through in-context learning.</p> <h2 id="is-text-a-viable-medium-for-learning">Is Text a Viable Medium for Learning?</h2> <p>In conventional gradient-based learning, progress accumulates in the model‚Äôs weights. These parameters absorb broad statistical structures and give models the general competence we rely on. But weight updates are not the only place where learning can happen.</p> <p>Text-based optimization suggests a complementary substrate: <strong>semantic space</strong>.</p> <p>This is especially promising for <strong>continual learning</strong>, where parameter updates often struggle because the knowledge stored inside the weights is highly entangled, new updates risk catastrophic forgetting and require careful regularization or access to past data. In contrast, textual artifacts <em>persist</em>. They accumulate naturally as the system operates, and grow in a form that LLMs can readily condition on. New feedback can be integrated immediately without retraining the underlying model.</p> <p>This is early territory. We don‚Äôt yet know the full limits of what can be stored or refined in semantic space. But the evidence so far suggests that text-level artifacts can absorb detailed feedback from the environment and unlock forms of improvement that are difficult or inefficient to achieve through weight updates alone. Understanding how to organize and scale this semantic layer, and how to integrate it cleanly with parameter learning, is an exciting direction for future work.</p> <hr/> <p>This post is based on our recent work ‚Äú<a href="https://arxiv.org/abs/2511.07919">Feedback Descent: Open-Ended Text Optimization via Pairwise Comparison</a>.‚Äù</p> <p>We thank Anikait Singh, Henrik Marklund, Mert Yuksekgonul, Jubayer Ibn Hamid, Allen Nie, Omar Khattab, Sergey Levine, SAIL blog editors (James Burgess, Megha Srivastava), and anonymous ICLR reviewers for their helpful feedback on earlier drafts.</p> <h3 id="footnotes">Footnotes</h3> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:dense"> <p>Dense rewards can help with temporal credit assignment, but don‚Äôt address the information bottleneck; a scalar at every step still doesn‚Äôt tell you what went wrong or how to fix it. Even when dense rewards are available, they‚Äôre notoriously hard to design well and prone to reward hacking. In practice, rewards for LLM post-training are usually sparse (outcome-based verification, human preferences), making this limitation especially acute.¬†<a href="#fnref:dense" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:rl-gap"> <p>Here, we‚Äôre primarily talking about policy gradients since that is the dominant paradigm for LLM post-training. Value-based methods are more sample-efficient because they propagate credit across time. However, this addresses temporal credit assignment while leaving the information bottleneck intact. This gap is exponential: <a href="https://arxiv.org/abs/1910.03016">Du et al.</a> show that even in settings where value functions are perfectly representable, RL requires exponentially more samples than richer supervision (i.e., imitation learning).¬†<a href="#fnref:rl-gap" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:cake-reference"> <p>This is, of course, a reference to <a href="https://youtu.be/Ount2Y4qxQo?si=oIrt0oFrwmGVWMM1&amp;t=1276">Yann LeCun‚Äôs cake analogy</a>. One ‚Äúcherry on top‚Äù is too little for some appetites üôÅ¬†<a href="#fnref:cake-reference" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:molecule-metadata"> <p>For clarity, we only show condensed feedback from two molecules in this table. In practice, the Feedback Descent system is shown full feedback on all top-k molecules proposed so far.¬†<a href="#fnref:molecule-metadata" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name>Yoonho Lee and Chelsea Finn</name></author><summary type="html"><![CDATA[Feedback Descent scales text-based optimization into a simple, domain-agnostic procedure that outperforms specialized RL methods across molecular design, prompt optimization, and visual editing.]]></summary></entry></feed>